<!DOCTYPE html>
<html>
<body style="background-color: black; color: white;">
    <button id='Quick Sort'>Quick Sort</button>
    <button id='Gravity Sort'>Gravity Sort</button>
    <button id='Selection Sort'>Selection Sort</button>
    <button id='Bubble Sort'>Bubble Sort</button>
    <button id='Merge Sort'>Merge Sort</button>
    <button id='Shell Sort'>Shell Sort</button>
    <button id='Cocktail Sort'>Cocktail Sort</button>
    <button id='Gnome Sort'>Insertion Sort</button>
    <button id='Bogo Sort' style="margin-right:120px;">Bogo Sort</button>
    Made Up Sorting Algorithms -->
    <button id='Know Sort'>Know Sort</button>
    <button id='Know Sort 2'>Know Sort 2</button>
    <button id='Cool Sort'>Cool Sort</button>
    <br>
    <br>
    <div></div>
    <canvas id="myCanvas" width="1400" height="650" style="border:1px solid #2a1baf;"></canvas>

    <input type="range" min="4" max="2000" value="1" class="slider" id="slider">
    Length of Array: <span id="choice"></span>
    <input id="Rectangles Type" type="text" style="margin-left:200px;">
    <br>
    <input type="range" min="1" max = "5" value="1" class="slideSpeed" id="slideSpeed">
    Speed: <span id="speed"></span>
    <span style="color:purple; margin-left:500px;">Correct Spot</span>
    <span style="color:white; margin-left:10px;">Incorrect Spot</span>
    <span style="color:red; margin-left:10px;">Smallest (Selection)</span>
    <span style="color:blue; margin-left:10px;">Current</span>
    <a href="#" class="neon-button" onclick="randomize();">Random</a>
    <div></div>
    <br>
    <button id='New'>Generate New Array</button>
    <button id="Stop">Pause</button>
    <style>
        :root {
        --clr-neon: hsl(317 100% 54%);
        --clr-bg: hsl(323 21% 16%);
        }
        .neon-button {
        margin-left: 80px;
        margin-bottom: 100px;
        font-size: 2rem;
        color: var(--clr-neon);
        display: infinite-block;
        text-decoration: none;
        border: var(--clr-neon) 0.125em solid;
        padding: .25em 1em;
        border-radius: 0.25em;
        text-shadow: 
            0 0 0.125em white, 0 0 0.2em currentColor; 
        box-shadow: 0 0 1em currentColor, inset 0 0 1em currentColor;
        position: relative;
        }
        .neon-button::before {
        pointer-events: none;
        content: "";
        position: absolute;
        background: var(--clr-neon);
        top: 120%;
        left: 0;
        width: 100%;
        height: 100%;
        transform: perspective(1em) rotateX(40deg) scale(1, 0.35);
        filter: blur(1em);
        opacity: 0.9;
        }

        .neon-button::after {
        content: "";
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        box-shadow: 0 0 3em 0.5em blue;
        opacity: 0;
        background-color: blue;
        z-index: -1;
        transition: opacity 100ms linear;
        }

        .neon-button:hover,
        .neon-button:focus {
        color: blue;
        text-shadow: blue;
        }

        .neon-button:hover::before,
        .neon-button:focus::before {
        opacity: 1;
        }
        .neon-button:hover::after,
        .neon-button:focus::after {
        opacity: 1;
        }
    </style>
    <script>
        var mode = "None";
        var lastMode = "None";
        var active = -1;
        var c = document.getElementById("myCanvas");
        var ctx = c.getContext("2d");
        var slider = document.getElementById("slider");
        var slideSpeed = document.getElementById("slideSpeed");
        var slideText = document.getElementById("choice");
        var speedText = document.getElementById("speed");
        var rectangleButton = document.getElementById("Rectangles Type");
        rectangleButton.value = "Enter Desired Length";
        var await = 0;
        var await2 = 0;
        var size = 4;
        var speed = 1;
        var minIndex = -1;
        slideText.innerHTML = size;
        speedText.innerHTML = speed;
        var arr = reset(size ,[]);
        var visited = [];
        var iterated = [];
        var buttonGen = document.getElementById('New');
        var buttonStop = document.getElementById('Stop');
        var buttonQuick = document.getElementById('Quick Sort');
        var buttonBubble = document.getElementById('Bubble Sort');
        var buttonGravity = document.getElementById('Gravity Sort');
        var buttonMerge = document.getElementById('Merge Sort');
        var buttonShell = document.getElementById('Shell Sort');
        var buttonCocktail = document.getElementById('Cocktail Sort');
        var buttonGnome = document.getElementById('Gnome Sort');
        var buttonKnow = document.getElementById('Know Sort');
        var buttonKnow2 = document.getElementById('Know Sort 2');
        var buttonCool = document.getElementById('Cool Sort');
        var buttonBogo = document.getElementById('Bogo Sort');
        var buttonSelection = document.getElementById('Selection Sort');
        var buttonRandom = document.getElementById('neon-button');

        function randomize() {
            mode = "None";
            arr = reset(arr.length);
            rand = Math.floor(Math.random() * 12);
            if (rand == 0) {
                buttonQuick.click();
            }
            else if (rand == 1) {
                buttonSelection.click();
            }
            else if (rand == 2) {
                buttonBubble.click();
            }
            else if (rand == 3) {
                buttonMerge.click();
            }
            else if (rand == 4) {
                buttonShell.click();
            }
            else if (rand == 5) {
                buttonCocktail.click();
            }
            else if (rand == 6) {
                buttonGnome.click();
            }
            else if (rand == 7) {
                buttonBogo.click();
            }
            else if (rand == 8) {
                buttonKnow.click();
            }
            else if (rand == 9) {
                buttonKnow2.click();
            }
            else if (rand == 10) {
                buttonCool.click();
            }
            else if (rand == 11) {
                buttonGravity.click();
            }
        }

        rectangleButton.onclick = function() {
            if (rectangleButton.value == "Enter Desired Length") {
                rectangleButton.value = "";
            }
        }
        document.body.onmousedown = function() {
            if (rectangleButton.value == "") {
                rectangleButton.value = "Enter Desired Length";
            }
        }
        rectangleButton.addEventListener("keyup", function() {
            if (/^-?\d+$/.test(rectangleButton.value)) {
                num = rectangleButton.value;
                if (+num >= 4 && +num <= 2000) {
                    minIndex = -1;
                    lastIndex = -1;
                    mode = "None";
                    arr = reset(+num);
                    size = num;
                    slider.value = num;
                    slideText.innerHTML = num;
                }
            }
        }, false);
        buttonGen.onclick = function() {
            minIndex = -1;
            lastMode = mode;
            mode = "None";
            arr = reset(arr.length);
        }
        buttonStop.onclick = function() {
            if (mode == "Cool") {
                await = 1;
            }
            if (mode == "Select") {
                await2 = 1;
            }
            lastMode = mode;
            mode = "None";      
        }

        /*
        buttonResume.onclick = function() {
            if (lastMode != "None") {
                mode = lastMode;
            }
            if (mode == "Quick") {
                quicksort();
            }
            else if (mode == "Bubble") {
                bubblesort();
            }
            else if (await2 == 1) {
                await2 = 0;
                mode = "Select";
                selectionsort();
            }
            else if (mode == "Merge") {
                visited = [];
                iterated = [];
                for (let i = 0; i < arr.length; i++) {
                    iterated.push(0);
                    visited.push(0);
                }
                mergesort(0, arr.length - 1);
            }
            else if (mode == "Know") {
                knowSort();
            }
            else if (mode == "Know2") {
                knowSort2();
            }
            else if (await == 1) {
                await = 0;
                mode = "Cool";
                coolSort();
            }
        }
        */
        buttonQuick.onclick = function() {
            minIndex = -1;
            if (mode != "Quick") {
                lastMode = mode;
                mode = "Quick";
                quicksort();
            }
        }
        buttonBubble.onclick = function() {
            minIndex = -1;
            if (mode != "Bubble") {
                lastMode = mode;
                mode = "Bubble";
                bubblesort();
            }
        }
        buttonGravity.onclick = function() {
            minIndex = -1;
            if (mode != "Gravity") {
                lastMode = mode;
                mode = "Gravity";
                gravitysort();
            }
        }
        buttonSelection.onclick = function() {
            minIndex = -1;
            if (mode != "Select") {
                lastMode = mode;
                mode = "Select";
                selectionsort();
            }
        }
        buttonBogo.onclick = function() {
            minIndex = -1;
            if (mode != "Bogo") {
                lastMode = mode;
                mode = "Bogo";
                bogosort();
            }
        }
        buttonMerge.onclick = function() {
            minIndex = -1;
            if (mode != "Merge") {
                lastMode = mode;
                mode = "Merge";
                visited = [];
                iterated = [];
                for (let i = 0; i < arr.length; i++) {
                    iterated.push(0);
                    visited.push(0);
                }
                mergesort(0, arr.length - 1);
            }
        }
        buttonShell.onclick = function() {
            minIndex = -1;
            if (mode != "Shell") {
                lastMode = mode;
                mode = "Shell";
                shellsort();
            }
        }
        buttonCocktail.onclick = function() {
            minIndex = -1;
            if (mode != "Cocktail") {
                lastMode = mode;
                mode = "Cocktail";
                cocktailsort();
            }
        }
        buttonGnome.onclick = function() {
            minIndex = -1;
            if (mode != "Gnome") {
                lastMode = mode;
                mode = "Gnome";
                gnomesort();
            }
        }
        buttonKnow.onclick = function() {
            minIndex = -1;
            if (mode != "Know") {
                lastMode = mode;
                mode = "Know";
                knowSort();
            }
        }
        buttonKnow2.onclick = function() {
            minIndex = -1;
            if (mode != "Know2") {
                lastMode = mode;
                mode = "Know2";
                knowSort2();
            }
        }
        buttonCool.onclick = function() {
            minIndex = -1;
            if (mode != "Cool") {
                lastMode = mode;
                mode = "Cool";
                coolSort();
            }
        }
        slider.oninput = function() {
            minIndex = -1;
            lastMode = mode;
            mode = "None";
            slideText.innerHTML = this.value;
            size = this.value;
            ctx.clearRect(0, 0, c.width, c.height);
            arr = reset(size);
        }
        slideSpeed.oninput = function() {
            speedText.innerHTML = this.value;
            speed = this.value;
        }

        async function bogosort() {
            let originalSize = arr.length;
            let i = arr.length - 1;
            let addOn = [];
            while (!isSorted()) {
                if (mode != "Bogo") {
                    break;
                }
                if (speed == 1) {
                    await sleep(300);
                }
                else if (speed == 2) {
                    await sleep(100);
                }
                else if (speed == 3) {
                    await sleep(20);
                }
                else if (speed == 4) {
                    await sleep(5);
                }
                else {
                    await sleep();
                }
                if (arr[i] - 1 == i) {
                    newArr = [i + 1];
                    addOn = newArr.concat(addOn);
                    i--;
                }
                arr = reset(arr.length - (arr.length - 1 - i)).concat(addOn);
                reset(arr.length, arr);
            }
        }

        async function gravitysort() {
            max = Math.max.apply(Array, arr);
            beads = [];
            for (let i = 0; i < max; i++) {
                beads[i] = []
                for (let j = max; j > arr[i]; j--) {
                    beads[i].push(0);
                }
                while (beads[i].length < max) {
                    beads[i].push(1);
                }
            }
            for (let i = 0; i < beads.length; i++) {
                if (mode != "Gravity") {
                    break;
                }
                let grav = false;
                while (!grav) {
                    if (mode != "Gravity") {
                        break;
                    }
                    for (let j = 0; j < max - 1; j++) {
                        if (mode != "Gravity") {
                            break;
                        }
                        if (beads[j][i] == 1) {
                            if (beads[j + 1][i] == 0) {
                                active = j;
                                beads[j][i] = 0;
                                beads[j + 1][i] = 1;
                            }
                        }
                    }
                    grav = true;
                    let one = false;
                    for (let j = 0; j < max - 1; j++) {
                        if (mode != "Gravity") {
                            break;
                        }
                        if (beads[j][i] == 1) {
                            one = true;
                        }
                        else {
                            if (one) {
                                grav = false;
                            }
                        }
                    }
                }
                await grav_helper();
            }
            await grav_helper();
        }

        async function grav_helper() {
            if (speed == 1) {
                await sleep(500);
            }
            else if (speed == 2) {
                await sleep(100);
            }
            else if (speed == 3) {
                await sleep(20);
            }
            else if (speed == 4) {
                await sleep();
            }
            for (let i = 0; i < arr.length; i++) {
                arr[i] = 0;
                for (let j = 0; j < arr.length; j++) {
                    arr[i] += beads[i][j];
                }
            }
            reset(arr.length, arr);
        }

        async function shellsort() {
            for (let i = Math.floor(arr.length / 2); i > 0; i = Math.floor(i / 2)) {
                if (mode != "Shell") {
                    break;
                }
                for (let j = i; j < arr.length; j++) {
                    if (mode != "Shell") {
                        break;
                    }
                    active = j;
                    let temp = arr[j];
                    let k;
                    for (k = j; k >= i && arr[k - i] > temp; k -= i) {
                        if (mode != "Shell") {
                            break;
                        }
                        active = k;
                        if (speed == 1) {
                            await sleep(500);
                        }
                        else if (speed == 2) {
                            await sleep(100);
                        }
                        else if (speed == 3) {
                            await sleep(20);
                        }
                        else if (speed == 4) {
                            await sleep();
                        }
                        arr[k] = arr[k - i];
                        reset(arr.length, arr);
                    }
                    arr[k] = temp;
                    reset(arr.length, arr);
                }
            }
        }

        function reset(size, ar = []) {
            nums = [];
            slide = false;
            if (ar == "") {
                for (let i = 1; i <= size; i++) {
                    nums.push(i);
                    slide = true;
                }
                while (nums.length > 0) {
                    const random = Math.floor(Math.random() * nums.length);
                    ar.push(nums[random]);
                    nums.splice(random, 1);
                }
            }

            ctx.clearRect(0, 0, c.width, c.height);
            for (let i = 0; i < size; i++) {
                ctx.fillStyle = 'white';
                if (i == active) {
                    ctx.fillStyle = 'blue';
                }
                else if (i == minIndex) {
                    ctx.fillStyle = 'red';
                }
                else if (i == ar[i] - 1) {
                    ctx.fillStyle = 'purple';
                }
                ctx.fillRect(i * (1400 / size), 0, 1400 / size, 600 / (size) * ar[i]);
            }
            return ar;
        }
        async function bin_search(arr, val, start, end) {
            active = start;
            reset(arr.length, arr);
            while (mode == "Quick") {
                if (speed == 1) {
                    await sleep(500);
                }
                else if (speed == 2) {
                    await sleep(100);
                }
                else if (speed == 3) {
                    await sleep(20);
                }
                else if (speed == 4) {
                    await sleep();
                }
                if (start == end) {
                    if (arr[start] > val) {
                        return start;
                    }
                    else {
                        return start + 1;
                    }
                }
                if (start > end) {
                    return start;
                }
                var mid = Math.floor((start + end) / 2);
                if (arr[mid] < val) {
                    return bin_search(arr, val, mid + 1, end);
                }
                else if (arr[mid] > val) {
                    return bin_search(arr, val, start, mid - 1);
                }
                else {
                    return mid;
                }
            }
        }
        async function quicksort() {
            let i = 0;
            while (i < arr.length) {
                active = i;
                if (mode != "Quick") {
                    break;
                }
                let val = arr[i];
                let j = await bin_search(arr, val, 0, i - 1);
                let slice2 = arr.slice(j, i);
                let slice3 = arr.slice(i + 1);
                arr = arr.slice(0, j);
                arr.push(val);
                arr = arr.concat(slice2);
                arr = arr.concat(slice3);
                reset(arr.length, arr);
                i++;
            }
            lastMode = mode;
            mode = "None";
            active = -1;
        }
        async function swap(a, b) {
            if (speed == 1) {
                await sleep(500);
            }
            else if (speed == 2) {
                await sleep(100);
            }
            else if (speed == 3) {
                await sleep(50);
            }
            else if (speed == 4) {
                await sleep(10);
            }
            else {
                await sleep();
            }
            temp1 = arr[a];
            arr[a] = arr[b];
            arr[b] = temp1;
        }
        async function swapKnow(a, b) {
            if (speed == 1) {
                await sleep(500);
            }
            else if (speed == 2) {
                await sleep(100);
            }
            else if (speed == 3) {
                await sleep(30);
            }
            else if (speed == 4) {
                await sleep();
            }
            temp1 = arr[a];
            arr[a] = arr[b];
            arr[b] = temp1;
        }

        async function bubblesort() {
            for (let i = 0; i < arr.length; i++) {
                sorted = true;
                for (let j = 0; j < arr.length - i - 1; j++) {
                    active = j;
                    if (arr[j] > arr[j + 1]) {
                        await swap(j, j + 1);
                        reset(arr.length, arr);
                        sorted = false;
                    }
                    if (mode != "Bubble") {
                        break;
                    }
                }
                if (mode != "Bubble") {
                    break;
                }
                if (sorted) {
                    break;
                }
            }
            lastMode = mode;
            mode = "None";
            active = -1;
        }

        async function selectionsort() {
            for (let i = 0; i < arr.length; i++) {
                if (mode != "Select") {
                    break;
                }
                minIndex = i;
                for (let j = i; j < arr.length; j++) {
                    if (mode != "Select") {
                        break;
                    }
                    active = j;
                    if (arr[j] < arr[minIndex]) {
                        minIndex = j;
                    }
                    await swap(1, 1);
                    reset(arr.length, arr);
                }
                await swap(i, minIndex);
                reset(arr.length, arr);
            }
            lastMode = mode;
            mode = "None";
            active = -1;
        }

        async function merge(start, end) {
            let mid = Math.floor((start + end) / 2);
            let startOne = start;
            let startTwo = mid + 1;
            let endOne = mid;
            let endTwo = end;
            let index = start;
            while (startOne <= endOne && startTwo <= endTwo) {
                if (mode != "Merge") {
                    break;
                }
                if (arr[startOne] <= arr[startTwo]) {
                    iterated[index] = arr[startOne];
                    index++;
                    startOne++;
                }
                else if(arr[startOne] > arr[startTwo]) {
                    iterated[index] = arr[startTwo];
                    index++;
                    startTwo++;
                }
            }
            while (startOne <= endOne) {
                if (mode != "Merge") {
                    break;
                }
                iterated[index] = arr[startOne]
                index++;
                startOne++;
            }
            while (startTwo <= endTwo) {
                if (mode != "Merge") {
                    break;
                }
                iterated[index] = arr[startTwo];
                index++;
                startTwo++;
            }
            index = start
            while (index < end + 1) {
                active = index;
                if (mode != "Merge") {
                    break;
                }
                arr[index] = iterated[index];
                if (speed == 1) {
                    await sleep(200);
                }
                else if (speed == 2) {
                    await sleep(50);
                }
                else if (speed == 3) {
                    await sleep(10);
                }
                else {
                    await sleep();
                }
                reset(arr.length, arr);
                index++;
            }
        }
        
        async function mergesort(start, end) {
            if (mode == "Merge") {
                if (start < end) {
                    let mid = Math.floor((start + end) / 2);
                    await mergesort(start, mid);
                    await mergesort(mid + 1, end);
                    await merge(start, end);
                    reset(arr.length, arr);
                }
            }
        }

        async function cocktailsort() {
            let recurse = 0;
            while (!isSorted()) {
                if (mode != "Cocktail") {
                    break;
                }
                if (recurse % 2 == 0) {
                    for (let i = 0; i < arr.length - 1; i++) {
                        if (mode != "Cocktail") {
                            break;
                        }
                        reset(arr.length, arr);
                        active = i
                        if (arr[i] > arr[i + 1]) {
                            await swap(i, i + 1);
                        }
                    }
                }
                else {
                    for (let i = arr.length - 1; i > 0; i--) {
                        if (mode != "Cocktail") {
                            break;
                        }
                        reset(arr.length, arr);
                        active = i
                        if (arr[i] < arr[i - 1]) {
                            await swap(i, i - 1);
                        }
                    }
                }
                recurse++;
            }
            lastMode = mode;
            mode = "None";
            active = -1;
        }

        async function gnomesort() {
            for (var i = 0; i < arr.length; i++) {
                if (mode != "Gnome") {
                    break;
                }
                for (var j = i; j > 0; j--) {
                    if (mode != "Gnome") {
                        break;
                    }
                    active = j;
                    if (arr[j] < arr[j - 1]) {
                        if (mode != "Gnome") {
                            break;
                        }
                        await swap(j, j - 1);
                        reset(arr.length, arr);
                    }
                }
            }
        }

        function isSorted() {
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] != i + 1) {
                    return false;
                }
            }
            return true;
        }

        async function knowSort() {
            for (let i = 0; i < arr.length; i++) {
                active = i;
                while (arr[i] != i + 1) {
                    if (mode != "Know") {
                        break;
                    }
                    await swapKnow(i, arr[i] - 1);
                    reset(arr.length, arr);
                }
                if (mode != "Know") {
                    break;
                }
            }
            lastMode = mode;
            mode = "None";
            active = -1;
        }

        async function knowSort2() {
            sorted = false;
  	        while (!sorted) {
                if (mode != "Know2") {
                    break;
                }
      	        sorted = true;
      	        for (let i = 0; i < arr.length; i++) {
                    active = i;
                    if (mode != "Know2") {
                        break;
                    }
        	        if (arr[arr[i] - 1] > arr[i]) {
              	        sorted = false;
                    }
        	        await swapKnow(i, arr[i] - 1);
                    reset(arr.length, arr);
      	        }
            }
            lastMode = mode;
            mode = "None";
            active = -1;
        }
        async function coolSort() {
            for (let i = 0, j = arr.length - 1; i < j; i++) {
                if (mode != "Cool") {
                    break;
                }
                await swapKnow(i, arr.indexOf(i + 1));
                active = i;
                reset(arr.length, arr);
                await swapKnow(j, arr.indexOf(j + 1));
                active = j;
                reset(arr.length, arr);
                j--;
            }
            lastMode = mode;
            mode = "None";
            active = -1;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
